/**
 * Game Store - Core game data management with Zustand
 */

import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import { produce } from 'immer';
import type { BeliefSystemMode, DailyCompletionSnapshot, GameData, Skills, SkillEntry } from '../types/game-data';
import type { CustomTask, MainQuest, Season, WeeklyGoal, Habit, RecurringTask, Chapter, Category, RewardSticker } from '../types/task';
import type { GameEvent, CreateEventParams } from '../types/event';
import { parseRewardTexts } from '../lib/reward-parser';
import { calculateLevelFromXP } from '../lib/player-progression';
import { normalizeLoggedTimeToMinutes } from '../lib/focus-time';
import { getEffectiveSeasonStatus } from '../lib/hierarchy-status';
import { createPrefixedId } from '../lib/id';
import {
  STORAGE_KEY,
  DEFAULT_SKILLS,
  DEFAULT_BELIEF_SYSTEM,
  DEFAULT_LORE_PROFILE,
  DEFAULT_WORLD_STATE,
  DEFAULT_PROGRESSION_CONFIG,
  DEFAULT_TITLE_CATALOG,
  DEFAULT_REWARD_PRICING,
  getCurrentMonthStr,
  toDateKey,
  parseLegacyDayString,
  calculateMonthlyMoneyFromRecords,
  computeDailySnapshotFromState,
  estimateRewardPricing,
  normalizeRewardVerb,
  clampNumber,
  getSkillPathCandidates,
  parseSkillPath,
  evaluateAutoTitleUnlockNames,
  generateAutoLoreTitle,
  resolveSeasonStatus,
  createStickerPlacement,
  parseDefinitionOfDone,
  isAutoGeneratedDoDTaskDescription,
  normalizeStoreData,
} from './game-store-helpers';

// Generate unique ID
const generateId = (prefix: string) => createPrefixedId(prefix, 9);

type SkillCategory = keyof Skills;
type SkillName<C extends SkillCategory> = keyof Skills[C];
type MutableSkillMap = { [K in SkillCategory]: Record<string, SkillEntry> };

// Initial state
const initialState: GameData = {
  stats: { life: 75, intelligence: 95, spirit: 95, action: 75, agility: 50, charm: 70 },
  level: 1,
  experience: 0,
  currentTitle: 'newbie',
  unlockedTitles: ['newbie'],

  dailyTasks: { shutdown: false, laugh: false, vision: false, walk: false, signal: false, log: false },
  lastReset: new Date().toDateString(),
  dailyCareCompleted: false,

  customTasks: [],
  archivedTasks: [],
  mainQuests: [],
  archivedMainQuests: [],
  recurringTasks: [],
  weeklyGoals: [],
  archivedWeeklyGoals: [],
  habits: [],
  archivedHabits: [],

  progressLog: [],
  taskLogs: [],

  skills: DEFAULT_SKILLS,
  beliefSystem: DEFAULT_BELIEF_SYSTEM,
  loreProfile: DEFAULT_LORE_PROFILE,
  worldState: DEFAULT_WORLD_STATE,
  progressionConfig: DEFAULT_PROGRESSION_CONFIG,
  titleCatalog: DEFAULT_TITLE_CATALOG,
  orchestrationLog: [],

  pomodoro: {
    completedToday: 0,
    lastPomodoroDate: new Date().toDateString(),
    totalCompleted: 0,
    lastUsedTaskId: null,
  },

  events: [],
  eventMemories: { summaries: [], coreEvents: [] },
  aiAnalysisHistory: [],

  resources: {
    time: { total: 0 },
    money: {
      balance: 0,
      monthlyIncome: 1800,
      monthlyBudget: 2400,
      monthlySpent: 0,
      monthlyNet: 1800,
      currentMonth: `${new Date().getFullYear()}-${String(new Date().getMonth() + 1).padStart(2, '0')}`,
    },
    energy: {
      current: 80,
      lastUpdate: new Date().toISOString(),
      lastSleepRecord: null,
    },
  },
  financialRecords: [],
  resourceLogs: [],
  rewardActionLogs: [],
  dailyCompletionSnapshots: {},
  energyHistory: [],
  journals: [],
  savedRewards: { quotes: [], knowledge: [], trivia: [], jokes: [], memes: [] },
  rewardPool: [],
  rewardPricing: DEFAULT_REWARD_PRICING,

  currentSeason: null,
  activeSeasons: [],
  seasonHistory: [],
  categories: [
    { id: 'work', name: 'Â∑•‰Ωú', icon: 'üíº', color: '#3b82f6' },
    { id: 'study', name: 'Â≠¶‰π†', icon: 'üìö', color: '#10b981' },
    { id: 'life', name: 'ÁîüÊ¥ª', icon: 'üè†', color: '#f59e0b' },
    { id: 'health', name: 'ÂÅ•Â∫∑', icon: 'üí™', color: '#ef4444' },
    { id: 'hobby', name: 'ÂÖ¥Ë∂£', icon: 'üé®', color: '#8b5cf6' },
    { id: 'finance', name: 'ÁêÜË¥¢', icon: 'üí∞', color: '#10b981' },
  ],
  transmigration: {
    permanentTitles: [],
    keyItems: [],
    unlockedSeasons: [],
    unlockedDungeons: [],
    totalLifetimeXP: 0,
  },

  monitor: {
    enabled: true,
    chartRange: 7,
    alertsEnabled: true,
    lastDailyReport: null,
    reportTime: 9,
    deadlineAlertTimes: [10, 14, 18],
  },

  questionnaires: {
    history: [],
    statistics: {},
    settings: {},
  },
};

// Store actions interface
interface GameActions {
  // Tasks
  addTask: (task: Omit<CustomTask, 'id' | 'createdAt' | 'completed' | 'status'>) => string;
  updateTask: (id: string, updates: Partial<CustomTask>) => void;
  deleteTask: (id: string) => void;
  startTask: (id: string) => void;
  completeTask: (id: string, review?: string, actualEnergyCost?: number, actualTimeCost?: number, reviewSatisfaction?: number) => void;
  archiveTask: (id: string) => void;
  unarchiveTask: (id: string) => void;
  clearArchivedTasks: () => void;

  // Recurring Tasks
  addRecurringTask: (task: Omit<RecurringTask, 'id' | 'createdAt' | 'streak' | 'lastGeneratedDate'>) => string;
  updateRecurringTask: (id: string, updates: Partial<RecurringTask>) => void;
  deleteRecurringTask: (id: string) => void;
  triggerRecurringTask: (id: string, customDate?: string) => void;
  checkRecurringTasks: () => void;

  // Main Quests
  addQuest: (quest: Omit<MainQuest, 'id' | 'createdAt'>) => string;
  updateQuest: (id: string, updates: Partial<MainQuest>) => void;
  deleteQuest: (id: string) => void;
  archiveQuest: (id: string) => void;
  unarchiveQuest: (id: string) => void;
  updateArchivedQuest: (id: string, updates: Partial<MainQuest>) => void;
  convertTaskToQuest: (taskId: string) => string | null; // Returns new quest ID

  // Seasons
  addSeason: (season: Omit<Season, 'id' | 'createdAt'>) => string;
  updateSeason: (id: string, updates: Partial<Season>) => void;
  updateChapter: (seasonId: string, chapterId: string, updates: Partial<Chapter>) => void;

  // Categories
  addCategory: (category: Omit<Category, 'id'>) => void;
  updateCategory: (id: string, updates: Partial<Category>) => void;
  deleteCategory: (id: string) => void;

  // Progress propagation - automatic progress calculation
  recalculateQuestProgress: (questId: string) => void;
  recalculateAllQuestProgress: () => void; // Batch recalculate all quest progress
  recalculateChapterProgress: (seasonId: string, chapterId: string) => void;
  recalculateAllChapterProgress: () => void; // Batch recalculate all chapters
  propagateProgressUp: (taskId: string) => void; // Task completion triggers upward propagation
  refreshTaskImportance: () => void; // Recalculate all tasks' importance based on linked quests

  // Weekly Goals
  addWeeklyGoal: (goal: Omit<WeeklyGoal, 'id' | 'createdAt'>) => string;
  updateWeeklyGoal: (id: string, updates: Partial<WeeklyGoal>) => void;
  deleteWeeklyGoal: (id: string) => void;
  archiveWeeklyGoal: (id: string) => void;

  // Habits
  addHabit: (habit: Omit<Habit, 'id' | 'createdAt' | 'streak' | 'longestStreak' | 'totalCompletions' | 'completionHistory'>) => string;
  updateHabit: (id: string, updates: Partial<Habit>) => void;
  deleteHabit: (id: string) => void;
  archiveHabit: (id: string) => void;
  unarchiveHabit: (id: string) => void;
  reorderHabits: (dragId: string, targetId: string, archived?: boolean) => void;
  checkInHabit: (id: string) => void;

  // Events
  createEvent: (params: CreateEventParams) => GameEvent;
  updateEventAnalysis: (eventId: string, analysis: GameEvent['analysis']) => void;

  // Resources
  updateEnergy: (change: number, reason: string) => void;
  updateMoney: (change: number, category: string, description?: string) => void;
  recalculateMonthlyMoney: (month?: string) => void;

  // Experience & Stats
  addExperience: (xp: number) => void;
  addSkillXP: <C extends SkillCategory>(category: C, skill: SkillName<C>, xp: number, reason?: string) => void;
  setSkillLevel: <C extends SkillCategory>(category: C, skill: SkillName<C>, level: number) => void;
  setBeliefMode: (mode: BeliefSystemMode) => void;
  setProfileBeliefs: (beliefs: string[]) => void;
  updateLoreProfile: (updates: Partial<GameData['loreProfile']>) => void;
  runOrchestrationCycle: (trigger: GameData['orchestrationLog'][number]['trigger'], note?: string) => void;
  resetPlayerStats: (newLevel?: number, newXP?: number) => void;
  updateStats: (statChanges: Partial<{ life: number; intelligence: number; spirit: number; action: number; agility: number; charm: number }>) => void;

  // Title
  setCurrentTitle: (title: string) => void;
  unlockTitle: (title: string) => void;
  removeTitle: (title: string) => void;
  redeemRewardSticker: (id: string) => { success: boolean; reason?: string };
  restoreRewardSticker: (id: string) => { success: boolean; reason?: string };
  deleteRewardSticker: (id: string) => void;
  updateRewardStickerPosition: (id: string, x: number, y: number, zIndex?: number) => void;
  updateRewardStickerData: (id: string, updates: Partial<Pick<RewardSticker, 'rawText' | 'verb' | 'object' | 'quantity' | 'unit'>>) => void;
  randomizeRewardBoardLayout: () => void;
  addRewardActionLog: (text: string) => void;
  updateRewardPricing: (updates: Partial<GameData['rewardPricing']>) => void;

  // Daily reset
  checkDailyReset: () => void;
  checkQuestUnlocks: () => void;

  // Data management
  loadFromJSON: (data: Partial<GameData>) => void;
  exportData: () => GameData;
  resetData: () => void;
}

type GameStore = GameData & GameActions;

export const useGameStore = create<GameStore>()(
  persist(
    (set, get) => ({
      ...initialState,

      // === Task Actions ===
      addTask: (taskData) => {
        const id = generateId('task');
        const newTask: CustomTask = {
          ...taskData,
          id,
          createdAt: new Date().toISOString(),
          completed: false,
          status: 'todo',
        };

        set((state) => ({
          customTasks: [...state.customTasks, newTask],
          taskLogs: [
            ...state.taskLogs,
            {
              type: 'create',
              task: { id, name: newTask.name },
              timestamp: new Date().toISOString(),
            },
          ],
        }));

        // Auto-refresh importance if needed
        if (newTask.linkedMainQuestId || newTask.linkType === 'season' || newTask.linkType === 'chapter') {
          get().refreshTaskImportance();
        }

        return id;
      },

      updateTask: (id, updates) => {
        const task = get().customTasks.find((t) => t.id === id);
        if (!task) return;

        // Log significant changes
        const logs: GameData['taskLogs'] = [];
        const timestamp = new Date().toISOString();

        if (updates.deadline && updates.deadline !== task.deadline) {
          logs.push({
            type: 'update',
            task: { id, name: task.name },
            timestamp,
            details: { field: 'deadline', old: task.deadline, new: updates.deadline }
          });
        }

        if (updates.name && updates.name !== task.name) {
          logs.push({
            type: 'update',
            task: { id, name: task.name },
            timestamp,
            details: { field: 'name', old: task.name, new: updates.name }
          });
        }

        // Detect checklist tick completion (DoD progress)
        if (updates.checklist && task.checklist) {
          const oldCompleted = task.checklist.filter(item => item.completed).length;
          const newCompleted = updates.checklist.filter(item => item.completed).length;

          if (newCompleted > oldCompleted) {
            // New items were checked - emit event
            console.log(`[updateTask] Checklist tick: ${oldCompleted} -> ${newCompleted} for task "${task.name}"`);
            get().createEvent({
              type: 'task.checklist_tick',
              entity: { type: 'task', id, name: task.name },
              details: {
                completedItems: newCompleted,
                totalItems: updates.checklist.length,
                newlyCompleted: newCompleted - oldCompleted
              }
            });
          }
        }

        // Apply status sync if needed
        const finalUpdates = { ...updates };
        // Normalize link fields to avoid stale season/chapter/quest bindings.
        if (updates.linkType) {
          if (updates.linkType === 'none') {
            finalUpdates.linkedMainQuestId = undefined;
            finalUpdates.linkedQuestId = undefined;
            finalUpdates.linkedSeasonId = undefined;
            finalUpdates.linkedChapterId = undefined;
            finalUpdates.seasonId = undefined;
          } else if (updates.linkType === 'mainQuest') {
            finalUpdates.linkedSeasonId = undefined;
            finalUpdates.linkedChapterId = undefined;
            finalUpdates.seasonId = undefined;
          } else if (updates.linkType === 'season') {
            finalUpdates.linkedMainQuestId = undefined;
            finalUpdates.linkedQuestId = undefined;
            finalUpdates.linkedChapterId = undefined;
            finalUpdates.seasonId = updates.linkedSeasonId ?? task.linkedSeasonId ?? task.seasonId;
          } else if (updates.linkType === 'chapter') {
            finalUpdates.linkedMainQuestId = undefined;
            finalUpdates.linkedQuestId = undefined;
            finalUpdates.seasonId = updates.linkedSeasonId ?? task.linkedSeasonId ?? task.seasonId;
          }
        }

        if (updates.status === 'completed') {
          finalUpdates.completed = true;
          if (!task.completedAt) {
            finalUpdates.completedAt = new Date().toISOString();
          }
        } else if (updates.status) {
          finalUpdates.completed = false;
          finalUpdates.completedAt = undefined;
        }

        set((state) => ({
          customTasks: state.customTasks.map((t) =>
            t.id === id ? { ...t, ...finalUpdates } : t
          ),
          taskLogs: [...state.taskLogs, ...logs]
        }));
      },

      deleteTask: (id) => {
        const task = get().customTasks.find((t) => t.id === id);
        if (!task) return;

        set((state) => ({
          customTasks: state.customTasks.filter((t) => t.id !== id),
          taskLogs: [
            ...state.taskLogs,
            {
              type: 'delete',
              task: { id, name: task.name },
              timestamp: new Date().toISOString(),
            },
          ],
        }));
      },

      startTask: (id) => {
        const task = get().customTasks.find((t) => t.id === id);
        if (!task) return;

        set((state) => ({
          customTasks: state.customTasks.map((t) =>
            t.id === id
              ? { ...t, status: 'in_progress', startedAt: new Date().toISOString() }
              : t
          ),
          taskLogs: [
            ...state.taskLogs,
            {
              type: 'update',
              task: { id, name: task.name },
              timestamp: new Date().toISOString(),
              details: { action: 'start' }
            },
          ],
        }));
      },

      completeTask: (id, review, actualEnergyCost, actualTimeCost, reviewSatisfaction) => {
        const task = get().customTasks.find((t) => t.id === id);
        if (!task) return;

        const completedAt = new Date().toISOString();
        let loggedFocusMinutes = normalizeLoggedTimeToMinutes(actualTimeCost);
        const pomodoroFocusMinutes = (task.pomodoroCount || 0) * 25;
        const taskTypeMultiplierMap: Record<string, number> = {
          creative: 1.7,
          tax: 1.3,
          maintenance: 0.8,
        };
        const taskTypeMultiplier = taskTypeMultiplierMap[task.taskType] || 1;

        // Support "fill either time or energy":
        // - Baseline conversion: 8 energy/hour => 7.5 minutes/energy.
        // - Task type coefficient is applied during conversion to reduce manual adjustment.
        const inferredTimeFromEnergy = (actualEnergyCost !== undefined && actualEnergyCost > 0 && loggedFocusMinutes <= 0)
          ? Math.round(actualEnergyCost * 7.5 * taskTypeMultiplier)
          : 0;
        if (loggedFocusMinutes <= 0 && inferredTimeFromEnergy > 0) {
          loggedFocusMinutes = inferredTimeFromEnergy;
        }

        const inferredBaseEnergyFromTime = (actualEnergyCost === undefined && loggedFocusMinutes > 0)
          ? Math.max(1, Math.round(loggedFocusMinutes / (7.5 * taskTypeMultiplier)))
          : undefined;
        const focusMinutesFromInput = Math.max(loggedFocusMinutes, pomodoroFocusMinutes);
        const effortEstimatedMinutesMap: Record<string, number> = {
          light: 25,
          medium: 60,
          heavy: 120,
          // Legacy mappings
          tiny: 25,
          moderate: 60,
          massive: 120,
        };
        const taskTypeMinuteMultiplierMap: Record<string, number> = {
          creative: 1.25,
          tax: 1.0,
          maintenance: 0.75,
        };
        const estimatedFocusMinutes = focusMinutesFromInput > 0
          ? 0
          : Math.max(
            10,
            Math.round(
              (effortEstimatedMinutesMap[task.effort as string] || 45) *
              (taskTypeMinuteMultiplierMap[task.taskType] || 1)
            )
          );
        const focusMinutesToAdd = Math.max(focusMinutesFromInput, estimatedFocusMinutes);
        let baseEnergyCost = 0;

        if (actualEnergyCost !== undefined && actualEnergyCost >= 0) {
          // User provided base cost
          baseEnergyCost = actualEnergyCost;
        } else if (inferredBaseEnergyFromTime !== undefined) {
          baseEnergyCost = inferredBaseEnergyFromTime;
        } else if (task.pomodoroCount && task.pomodoroCount > 0) {
          // Pomodoro based base cost (4 energy per pomodoro)
          baseEnergyCost = task.pomodoroCount * 4;
        } else {
          // Effort based base cost
          const effortCostMap: Record<string, number> = {
            light: 4,
            medium: 10,
            heavy: 30,
            // Legacy mappings
            tiny: 4,
            moderate: 10,
            massive: 30
          };
          baseEnergyCost = effortCostMap[task.effort as string] || 5;
        }

        // Task type coefficient
        const finalEnergyCost = Math.max(0, Math.ceil(baseEnergyCost * taskTypeMultiplier));

        // Automatic gold reward on task completion
        const goldBaseByEffort: Record<string, number> = {
          light: 10,
          medium: 18,
          heavy: 30,
          // Legacy mappings
          tiny: 10,
          moderate: 18,
          massive: 30,
        };
        const goldImportanceCoefMap: Record<string, number> = {
          low: 0.8,
          medium: 1.0,
          high: 1.25,
        };
        const goldTaskTypeCoefMap: Record<string, number> = {
          creative: 1.15,
          tax: 1.0,
          maintenance: 0.9,
        };
        const goldBase = goldBaseByEffort[task.effort as string] ?? 12;
        const goldImportanceCoef = goldImportanceCoefMap[task.importance] ?? 1;
        const goldTaskTypeCoef = goldTaskTypeCoefMap[task.taskType] ?? 1;
        const goldSatisfactionCoef = clampNumber((reviewSatisfaction ?? 3) / 3, 0.8, 1.3);
        const goldGain = Math.max(
          1,
          Math.ceil(goldBase * goldImportanceCoef * goldTaskTypeCoef * goldSatisfactionCoef)
        );

        // Apply energy deduction (energy floor/ceiling is handled inside updateEnergy)
        if (finalEnergyCost > 0) {
          get().updateEnergy(-finalEnergyCost, 'task_completion');
        }

        const rewardText = task.motivation?.trim();
        const parsedRewards = rewardText ? parseRewardTexts(rewardText) : [];
        const rewardPricing = get().rewardPricing || DEFAULT_REWARD_PRICING;
        const occupiedPositions = (get().rewardPool || [])
          .filter((item) => item.status === 'available')
          .map((item) => ({ x: item.x, y: item.y }));
        const rewardStickers: RewardSticker[] = parsedRewards.map((parsed) => {
          const placement = createStickerPlacement(occupiedPositions);
          const pricing = estimateRewardPricing(parsed.verb, parsed.quantity, rewardPricing);
          occupiedPositions.push({ x: placement.x, y: placement.y });
          return {
            id: generateId('reward'),
            rawText: parsed.rawText,
            verb: parsed.verb,
            object: parsed.object,
            quantity: parsed.quantity,
            unit: parsed.unit,
            sourceTaskId: task.id,
            sourceTaskName: task.name,
            status: 'available',
            priceTier: pricing.priceTier,
            priceGold: pricing.priceGold,
            createdAt: completedAt,
            x: placement.x,
            y: placement.y,
            rotation: placement.rotation,
            zIndex: placement.zIndex,
          };
        });

        set((state) => {
          // Keep money ledger and monthly summary in sync with automatic task income.
          const moneyRecord: GameData['financialRecords'][number] = {
            id: generateId('fin'),
            type: 'income',
            amount: goldGain,
            category: 'task_completion',
            source: 'system',
            relatedEntityType: 'task',
            relatedEntityId: task.id,
            description: `Task completion: ${task.name}`,
            date: completedAt,
          };
          const nextFinancialRecords = [...state.financialRecords, moneyRecord];
          const nextMonth = getCurrentMonthStr(new Date(completedAt));
          const monthSummary = calculateMonthlyMoneyFromRecords(nextFinancialRecords, nextMonth);

          return {
            financialRecords: nextFinancialRecords,
            customTasks: state.customTasks.map((t) =>
              t.id === id
                ? {
                  ...t,
                  completed: true,
                  status: 'completed',
                  completedAt,
                  review,
                  reviewSatisfaction,
                  actualCosts: {
                    ...t.actualCosts,
                    energy: finalEnergyCost,
                    time: focusMinutesToAdd > 0
                      ? focusMinutesToAdd
                      : t.actualCosts?.time,
                  }
                }
                : t
            ),
            resources: {
              ...state.resources,
              time: {
                ...state.resources.time,
                total: Math.max(0, (state.resources.time.total || 0) + focusMinutesToAdd),
              },
              money: {
                ...state.resources.money,
                balance: state.resources.money.balance + goldGain,
                currentMonth: nextMonth,
                monthlyIncome: monthSummary.income,
                monthlySpent: monthSummary.spent,
                monthlyNet: monthSummary.income - monthSummary.spent,
              },
            },
            taskLogs: [
              ...state.taskLogs,
              {
                type: 'complete',
                task: { id, name: task.name },
                timestamp: completedAt,
                review,
                reviewSatisfaction,
                details: {
                  baseEnergyCost,
                  multiplier: taskTypeMultiplier,
                  energyCost: finalEnergyCost,
                  netDeduction: finalEnergyCost,
                  goldGain,
                }
              },
            ],
            rewardPool: rewardStickers.length > 0 ? [...rewardStickers, ...(state.rewardPool || [])] : (state.rewardPool || []),
          };
        });

        // Propagate progress up the hierarchy
        get().propagateProgressUp(id);

        const importanceCoefMap: Record<string, number> = {
          low: 0.9,
          medium: 1.0,
          high: 1.2,
        };
        const effortCoefMap: Record<string, number> = {
          light: 0.9,
          medium: 1.1,
          heavy: 1.3,
          tiny: 0.9,
          moderate: 1.1,
          massive: 1.3,
        };
        const expectedMinutesByEffort: Record<string, number> = {
          light: 25,
          medium: 60,
          heavy: 120,
          tiny: 25,
          moderate: 60,
          massive: 120,
        };
        const baselineEnergyByEffort: Record<string, number> = {
          light: 4,
          medium: 10,
          heavy: 30,
          tiny: 4,
          moderate: 10,
          massive: 30,
        };
        const baseXP = 8;
        const importanceCoef = importanceCoefMap[task.importance] ?? 1;
        const effortCoef = effortCoefMap[task.effort as string] ?? 1;
        const qualityCoef = review?.trim() ? 1.08 : 1;
        const expectedMinutes = expectedMinutesByEffort[task.effort as string] ?? 60;
        const actualMinutes = focusMinutesToAdd > 0 ? focusMinutesToAdd : expectedMinutes;
        const timeCoef = clampNumber(actualMinutes / Math.max(1, expectedMinutes), 0.8, 1.2);
        const baselineEnergy = baselineEnergyByEffort[task.effort as string] ?? 10;
        const energyCoef = clampNumber(finalEnergyCost / Math.max(1, baselineEnergy), 0.9, 1.1);
        const xpGain = Math.max(
          1,
          Math.min(40, Math.ceil(baseXP * importanceCoef * effortCoef * qualityCoef * timeCoef * energyCoef))
        );

        get().addExperience(xpGain);

        // Create completion event with XP factors for auditability
        get().createEvent({
          type: 'task.completed',
          entity: { type: 'task', id: task.id, name: task.name },
          details: {
            review,
            energyCost: finalEnergyCost,
            goldGain,
            xpGain,
            xpFactors: { baseXP, importanceCoef, effortCoef, qualityCoef, timeCoef, energyCoef },
          },
        });

        const progressionConfig = get().progressionConfig;
        const taskRule = getSkillPathCandidates(task.taskType, progressionConfig);
        const primarySkills = taskRule.primarySkills || [];
        const secondarySkills = taskRule.secondarySkills || [];
        const primaryXP = Math.max(1, Math.ceil(xpGain * 0.4));
        const secondaryXP = Math.max(1, Math.ceil(xpGain * 0.2));
        for (const path of primarySkills.slice(0, 2)) {
          const parsed = parseSkillPath(path);
          if (!parsed) continue;
          const skillName = parsed.skill as SkillName<typeof parsed.category>;
          get().addSkillXP(parsed.category, skillName, primaryXP, 'task_completion_primary');
        }
        for (const path of secondarySkills.slice(0, 2)) {
          const parsed = parseSkillPath(path);
          if (!parsed) continue;
          const skillName = parsed.skill as SkillName<typeof parsed.category>;
          get().addSkillXP(parsed.category, skillName, secondaryXP, 'task_completion_secondary');
        }

        const safeSatisfaction = clampNumber((reviewSatisfaction || 3) / 3, 0.7, 1.5);
        const attributeDelta: Partial<Record<'life' | 'intelligence' | 'spirit' | 'action' | 'agility' | 'charm', number>> = {};
        for (const [attrKey, weight] of Object.entries(taskRule.attributeWeights || {})) {
          const gain = Math.max(0, Math.ceil((weight || 0) * 2 * safeSatisfaction));
          if (gain <= 0) continue;
          if (['life', 'intelligence', 'spirit', 'action', 'agility', 'charm'].includes(attrKey)) {
            const typedAttrKey = attrKey as keyof typeof attributeDelta;
            attributeDelta[typedAttrKey] = gain;
          }
        }
        if (Object.keys(attributeDelta).length > 0) {
          get().updateStats(attributeDelta);
        }

        const unlockedNames = evaluateAutoTitleUnlockNames(get() as unknown as GameData);
        unlockedNames.forEach((name) => get().unlockTitle(name));
      },

      archiveTask: (id) => {
        const task = get().customTasks.find((t) => t.id === id);
        if (!task) return;

        set((state) => ({
          customTasks: state.customTasks.filter((t) => t.id !== id),
          archivedTasks: [
            { ...task, archivedAt: new Date().toISOString() },
            ...state.archivedTasks,
          ],
          taskLogs: [
            ...state.taskLogs,
            {
              type: 'archive',
              task: { id, name: task.name },
              timestamp: new Date().toISOString(),
            },
          ],
        }));

        // Recalculate linked quest progress after archiving
        if (task.linkedMainQuestId) {
          get().recalculateQuestProgress(task.linkedMainQuestId);
        }
      },

      unarchiveTask: (id) => {
        const task = get().archivedTasks.find((t) => t.id === id);
        if (!task) return;

        const { archivedAt, archiveReason, ...taskData } = task;

        // Reset completion status when unarchiving (assume user wants to continue working on it or fixed a mistake)
        const activeTask = {
          ...taskData,
          completed: false,
          completedAt: undefined
        };

        set((state) => ({
          archivedTasks: state.archivedTasks.filter((t) => t.id !== id),
          customTasks: [...state.customTasks, activeTask],
        }));

        // Recalculate linked quest progress after unarchiving
        if (task.linkedMainQuestId) {
          get().recalculateQuestProgress(task.linkedMainQuestId);
        }
      },

      clearArchivedTasks: () => {
        set({ archivedTasks: [] });
      },

      // === Recurring Task Actions ===
      addRecurringTask: (taskData) => {
        const id = generateId('rt');
        const newTask: RecurringTask = {
          ...taskData,
          id,
          createdAt: new Date().toISOString(),
          streak: 0,
        };

        set((state) => ({
          recurringTasks: [...state.recurringTasks, newTask],
        }));

        get().checkRecurringTasks(); // Check immediately upon creation
        return id;
      },

      updateRecurringTask: (id, updates) => {
        set((state) => ({
          recurringTasks: state.recurringTasks.map((t) =>
            t.id === id ? { ...t, ...updates } : t
          ),
        }));
      },

      deleteRecurringTask: (id) => {
        set((state) => ({
          recurringTasks: state.recurringTasks.filter((t) => t.id !== id),
        }));
      },

      triggerRecurringTask: (id, customDate) => {
        const state = get();
        const rule = state.recurringTasks.find((t) => t.id === id);
        if (!rule) return;

        // Default deadline to today if not provided
        const todayStr = new Date().toISOString().split('T')[0];
        const deadline = customDate || todayStr;

        get().addTask({
          name: rule.name,
          description: rule.description,
          importance: rule.importance,
          effort: rule.effort,
          taskType: rule.taskType,
          linkType: rule.linkedMainQuestId ? 'mainQuest' : rule.linkedSeasonId ? 'season' : 'none',
          linkedMainQuestId: rule.linkedMainQuestId,
          linkedSeasonId: rule.linkedSeasonId,
          seasonId: rule.linkedSeasonId,
          deadline: deadline,
        });

        if (!customDate || customDate === todayStr) {
          get().updateRecurringTask(id, { lastGeneratedDate: todayStr });
        }
      },

      checkRecurringTasks: () => {
        const state = get();
        const today = new Date();
        const todayStr = today.getFullYear() + '-' + String(today.getMonth() + 1).padStart(2, '0') + '-' + String(today.getDate()).padStart(2, '0');
        const dayOfWeek = today.getDay(); // 0-6
        const dayOfMonth = today.getDate(); // 1-31

        state.recurringTasks.forEach((rule) => {
          if (!rule.enabled) return;

          // Date Range Check
          if (rule.startDate && todayStr < rule.startDate) return;
          if (rule.endDate && todayStr > rule.endDate) return;

          // Check if already generated today
          if (rule.lastGeneratedDate === todayStr) return;

          let shouldGenerate = false;

          if (rule.frequency === 'daily') {
            shouldGenerate = true;
          } else if (rule.frequency === 'weekly' && rule.daysOfWeek?.includes(dayOfWeek)) {
            shouldGenerate = true;
          } else if (rule.frequency === 'monthly' && rule.dayOfMonth === dayOfMonth) {
            shouldGenerate = true;
          }

          if (shouldGenerate) {
            // Calculate deadline based on frequency
            let deadline: string | undefined;

            if (rule.frequency === 'daily') {
              // Daily task: deadline is today
              deadline = todayStr;
            } else if (rule.frequency === 'weekly' && rule.daysOfWeek && rule.daysOfWeek.length > 0) {
              // Weekly task: deadline is the next occurrence of the specified day
              // If multiple days, use the current day (since we're generating on that day)
              deadline = todayStr;
            } else if (rule.frequency === 'monthly') {
              // Monthly task: deadline is today (the day it's generated)
              deadline = todayStr;
            }

            console.log(`[checkRecurringTasks] Generating task "${rule.name}" with deadline: ${deadline}`);

            // Generate Task with deadline
            get().addTask({
              name: rule.name,
              description: rule.description,
              importance: rule.importance,
              effort: rule.effort,
              taskType: rule.taskType,
              linkType: rule.linkedMainQuestId ? 'mainQuest' : rule.linkedSeasonId ? 'season' : 'none',
              linkedMainQuestId: rule.linkedMainQuestId,
              linkedSeasonId: rule.linkedSeasonId,
              seasonId: rule.linkedSeasonId, // Dual mapping for compatibility
              deadline: deadline,
            });

            // Mark as generated
            get().updateRecurringTask(rule.id, { lastGeneratedDate: todayStr });
          }
        });
      },

      // === Quest Actions ===
      addQuest: (questData) => {
        const id = generateId('mq');
        const newQuest: MainQuest = {
          ...questData,
          id,
          createdAt: new Date().toISOString(),
        };

        set((state) => ({
          mainQuests: [...state.mainQuests, newQuest],
        }));

        get().createEvent({
          type: 'quest.created',
          entity: { type: 'quest', id, name: newQuest.title },
        });

        // Auto-generate tasks from Definition of Done
        if (questData.definitionOfDone) {
          const dodItems = parseDefinitionOfDone(questData.definitionOfDone);
          console.log(`[addQuest] Parsed ${dodItems.length} DoD items from quest "${newQuest.title}":`, dodItems);

          dodItems.forEach((item, index) => {
            get().addTask({
              name: item,
              description: `‰ªéÂâØÊú¨„Äå${newQuest.title}„ÄçÁöÑ Definition of Done Ëá™Âä®ÁîüÊàê`,
              importance: questData.importance || 'medium',
              effort: 'light', // Default effort for DoD items
              taskType: 'creative',
              linkType: 'mainQuest',
              linkedMainQuestId: id,
              // Inherit deadline from quest if available
              deadline: questData.deadline,
            });
            console.log(`[addQuest] Created task ${index + 1}: "${item}"`);
          });

          // Update quest progress tracking
          if (dodItems.length > 0) {
            get().updateQuest(id, {
              progressTracking: {
                mode: 'auto',
                linkedTasksCount: dodItems.length,
                completedTasksCount: 0,
                autoProgress: 0,
                manualProgress: 0,
              },
            });
          }
        }

        if (newQuest.linkedChapterId && newQuest.seasonId) {
          get().recalculateChapterProgress(newQuest.seasonId, newQuest.linkedChapterId);
        }

        return id;
      },

      updateQuest: (id, updates) => {
        const quest = get().mainQuests.find((q) => q.id === id);

        // Auto-update status based on unlockTime
        const finalUpdates = { ...updates };
        if (updates.unlockTime !== undefined) {
          const unlockTimeValue = updates.unlockTime?.trim();
          if (unlockTimeValue && unlockTimeValue.match(/^\d{4}-\d{2}-\d{2}$/)) {
            // Parse as local date to avoid timezone issues
            const [year, month, day] = unlockTimeValue.split('-').map(Number);
            const unlockDate = new Date(year, month - 1, day);
            unlockDate.setHours(0, 0, 0, 0);

            const today = new Date();
            today.setHours(0, 0, 0, 0);

            console.log('[updateQuest] Unlock date check:', { unlockTimeValue, unlockDate: unlockDate.toISOString(), today: today.toISOString(), isFuture: unlockDate > today });

            if (unlockDate > today) {
              // Future unlock date (tomorrow or later) - set to locked
              finalUpdates.status = 'locked';
            } else if (quest?.status === 'locked') {
              // Unlock date is today or past - unlock it
              finalUpdates.status = 'active';
            }
          } else if (!unlockTimeValue && quest?.status === 'locked') {
            // No unlock time set, unlock it
            finalUpdates.status = 'active';
          }
        }

        set((state) => ({
          mainQuests: state.mainQuests.map((q) =>
            q.id === id ? { ...q, ...finalUpdates } : q
          ),
        }));

        // If quest is being completed, unlock reward title
        if (finalUpdates.status === 'completed' && quest) {
          const rewardTitleName = quest.rewardTitle?.trim()
            ? quest.rewardTitle.trim()
            : generateAutoLoreTitle('quest', quest.title, get().loreProfile).name;
          get().unlockTitle(rewardTitleName);
          if (!quest.rewardTitle?.trim()) {
            const autoTitle = generateAutoLoreTitle('quest', quest.title, get().loreProfile);
            set((state) => ({
              titleCatalog: {
                ...state.titleCatalog,
                generatedTitles: [
                  {
                    id: `title_auto_quest_${quest.id}`,
                    name: autoTitle.name,
                    description: autoTitle.description,
                    rarity: autoTitle.rarity,
                    sourceType: 'quest',
                    sourceId: quest.id,
                    unlockedAt: new Date().toISOString(),
                    autoGenerated: true,
                  },
                  ...state.titleCatalog.generatedTitles.filter((t) => t.id !== `title_auto_quest_${quest.id}`),
                ],
                unlockHistory: [
                  {
                    titleId: `title_auto_quest_${quest.id}`,
                    reason: 'quest_completed_auto_title',
                    timestamp: new Date().toISOString(),
                  },
                  ...state.titleCatalog.unlockHistory,
                ].slice(0, 500),
              },
            }));
          }
          if (quest.rewardXP) {
            get().addExperience(quest.rewardXP);
          }
          get().runOrchestrationCycle('quest_completed', `quest=${quest.title}`);
        }

        if (quest?.linkedChapterId && quest?.seasonId) {
          get().recalculateChapterProgress(quest.seasonId, quest.linkedChapterId);
        }

        // Auto-refresh task importance calculations if quest importance changed
        if (finalUpdates.importance !== undefined && quest && finalUpdates.importance !== quest.importance) {
          get().refreshTaskImportance();
        }

        // Sync DoD tasks when definitionOfDone is updated
        if (updates.definitionOfDone !== undefined && quest) {
          const newDod = updates.definitionOfDone || '';

          console.log('[updateQuest] DoD sync triggered...');

          const newItems = parseDefinitionOfDone(newDod);

          // Only sync DoD auto-generated tasks.
          // Manually created quest-linked tasks must never be removed by DoD sync.
          const linkedAutoDodTasks = get().customTasks.filter(
            (t) => t.linkedMainQuestId === id && isAutoGeneratedDoDTaskDescription(t.description)
          );
          const existingTaskNames = linkedAutoDodTasks.map((t) => t.name);

          // Find items to add (in new DoD but no matching existing task)
          const itemsToAdd = newItems.filter(item => !existingTaskNames.includes(item));

          // Find tasks to remove (existing tasks whose name is not in new DoD)
          const tasksToRemove = linkedAutoDodTasks.filter((t) => !newItems.includes(t.name));

          console.log('[updateQuest] DoD sync:', {
            newItems,
            existingTaskNames,
            itemsToAdd,
            tasksToRemove: tasksToRemove.map(t => ({ name: t.name, status: t.status }))
          });

          // Add new tasks
          itemsToAdd.forEach((item) => {
            get().addTask({
              name: item,
              description: `‰ªéÂâØÊú¨„Äå${quest.title}„ÄçÁöÑ Definition of Done Ëá™Âä®ÁîüÊàê`,
              importance: updates.importance || quest.importance || 'medium',
              effort: 'light',
              taskType: 'creative',
              linkType: 'mainQuest',
              linkedMainQuestId: id,
              deadline: updates.deadline || quest.deadline,
            });
            console.log(`[updateQuest] Added DoD task: "${item}"`);
          });

          // Remove tasks (all matching tasks, regardless of status)
          tasksToRemove.forEach((task) => {
            get().deleteTask(task.id);
            console.log(`[updateQuest] Removed DoD task: "${task.name}" (was ${task.status})`);
          });

          // Recalculate quest progress
          if (itemsToAdd.length > 0 || tasksToRemove.length > 0) {
            get().recalculateQuestProgress(id);
          }
        }
      },

      deleteQuest: (id) => {
        set((state) => ({
          mainQuests: state.mainQuests.filter((q) => q.id !== id),
        }));
      },

      archiveQuest: (id) => {
        const quest = get().mainQuests.find((q) => q.id === id);
        if (!quest) return;

        set((state) => ({
          mainQuests: state.mainQuests.filter((q) => q.id !== id),
          archivedMainQuests: [
            ...state.archivedMainQuests,
            { ...quest, status: 'archived' as const, archivedAt: new Date().toISOString() },
          ],
        }));
      },

      unarchiveQuest: (id) => {
        const quest = get().archivedMainQuests.find((q) => q.id === id);
        if (!quest) return;

        set((state) => ({
          archivedMainQuests: state.archivedMainQuests.filter((q) => q.id !== id),
          mainQuests: [...state.mainQuests, { ...quest, status: 'active' as const }],
        }));
      },

      updateArchivedQuest: (id, updates) => {
        set((state) => ({
          archivedMainQuests: state.archivedMainQuests.map((quest) =>
            quest.id === id ? { ...quest, ...updates } : quest
          ),
        }));
      },

      convertTaskToQuest: (taskId) => {
        const task = get().customTasks.find((t) => t.id === taskId);
        if (!task) return null;

        const checklistItems = (task.checklist || [])
          .map((item) => ({
            text: item.text.trim(),
            completed: item.completed,
          }))
          .filter((item) => item.text.length > 0);

        const definitionOfDone = checklistItems.length > 0
          ? checklistItems.map((item) => `- ${item.text}`).join('\n')
          : undefined;

        // Create new quest from task
        const questId = generateId('mq');
        const newQuest: MainQuest = {
          id: questId,
          title: task.name,
          description: task.description,
          context: task.context?.trim() || undefined,
          definitionOfDone,
          createdAt: new Date().toISOString(),
          progressType: 'percentage',
          progress: 0,
          status: 'active',
          importance: task.importance,
          deadline: task.deadline,
          linkedChapterId: task.linkedChapterId,
          seasonId: task.seasonId || task.linkedSeasonId,
          progressTracking: {
            mode: 'auto',
            linkedTasksCount: 0,
            completedTasksCount: 0,
            autoProgress: 0,
            manualProgress: 0,
          },
        };

        // Delete the original task
        set((state) => ({
          customTasks: state.customTasks.filter((t) => t.id !== taskId),
          mainQuests: [...state.mainQuests, newQuest],
        }));

        // Promote DoD checklist items into quest-linked tasks
        checklistItems.forEach((item) => {
          const newTaskId = get().addTask({
            name: item.text,
            description: `Definition of Done auto-generated from quest "${newQuest.title}"`,
            context: task.context?.trim() || undefined,
            importance: task.importance,
            effort: 'light',
            taskType: 'creative',
            linkType: 'mainQuest',
            linkedMainQuestId: questId,
            deadline: task.deadline,
          });

          if (item.completed) {
            get().updateTask(newTaskId, { status: 'completed' });
          }
        });

        if (checklistItems.length > 0) {
          get().recalculateQuestProgress(questId);
        }

        // Create event
        get().createEvent({
          type: 'task.promoted',
          entity: { type: 'task', id: taskId, name: task.name },
          details: { newQuestId: questId },
        });

        return questId;
      },

      // === Season Actions ===
      addSeason: (seasonData) => {
        const id = generateId('season');
        const newSeason: Season = {
          ...seasonData,
          id,
          createdAt: new Date().toISOString(),
          status: resolveSeasonStatus(
            seasonData.status ?? 'active',
            seasonData.startDate,
            seasonData.status
          ),
        };

        set((state) => ({
          activeSeasons: [...state.activeSeasons, newSeason],
        }));

        get().createEvent({
          type: 'season.created',
          entity: { type: 'season', id, name: newSeason.name },
        });

        return id;
      },

      updateSeason: (id, updates) => {
        const prevSeason = get().activeSeasons.find((s) => s.id === id);
        set((state) => ({
          activeSeasons: state.activeSeasons.map((season) =>
            season.id === id
              ? (() => {
                const merged = { ...season, ...updates };
                return {
                  ...merged,
                  status: resolveSeasonStatus(
                    season.status,
                    merged.startDate,
                    updates.status
                  ),
                };
              })()
              : season
          ),
        }));
        const nextSeason = get().activeSeasons.find((s) => s.id === id);
        if (prevSeason && nextSeason && prevSeason.status !== 'completed' && nextSeason.status === 'completed') {
          const seasonTitleName = nextSeason.rewardTitle?.trim()
            ? nextSeason.rewardTitle.trim()
            : generateAutoLoreTitle('season', nextSeason.name, get().loreProfile).name;
          get().unlockTitle(seasonTitleName);
          if (!nextSeason.rewardTitle?.trim()) {
            const autoTitle = generateAutoLoreTitle('season', nextSeason.name, get().loreProfile);
            set((state) => ({
              titleCatalog: {
                ...state.titleCatalog,
                generatedTitles: [
                  {
                    id: `title_auto_season_${nextSeason.id}`,
                    name: autoTitle.name,
                    description: autoTitle.description,
                    rarity: autoTitle.rarity,
                    sourceType: 'season',
                    sourceId: nextSeason.id,
                    unlockedAt: new Date().toISOString(),
                    autoGenerated: true,
                  },
                  ...state.titleCatalog.generatedTitles.filter((t) => t.id !== `title_auto_season_${nextSeason.id}`),
                ],
                unlockHistory: [
                  {
                    titleId: `title_auto_season_${nextSeason.id}`,
                    reason: 'season_completed_auto_title',
                    timestamp: new Date().toISOString(),
                  },
                  ...state.titleCatalog.unlockHistory,
                ].slice(0, 500),
              },
            }));
          }
          if (nextSeason.rewardXP) {
            get().addExperience(nextSeason.rewardXP);
          }
        }
      },

      updateChapter: (seasonId, chapterId, updates) => {
        set((state) => ({
          activeSeasons: state.activeSeasons.map((season) =>
            season.id === seasonId
              ? {
                ...season,
                chapters: season.chapters.map((c) =>
                  c.id === chapterId ? { ...c, ...updates } : c
                ),
              }
              : season
          ),
        }));
      },

      // === Categories ===
      addCategory: (category) => {
        const newCategory: Category = { ...category, id: generateId('cat') };
        set((state) => ({
          categories: [...state.categories, newCategory],
        }));
      },

      updateCategory: (id, updates) => {
        set((state) => ({
          categories: state.categories.map((c) =>
            c.id === id ? { ...c, ...updates } : c
          ),
        }));
      },

      deleteCategory: (id) => {
        set((state) => ({
          categories: state.categories.filter((c) => c.id !== id),
        }));
      },

      // === Progress Propagation Actions ===
      recalculateQuestProgress: (questId) => {
        const state = get();
        const quest = state.mainQuests.find((q) => q.id === questId);
        if (!quest) return;

        // Find all tasks linked to this quest (both active and archived)
        const activeLinkedTasks = state.customTasks.filter(
          (t) => t.linkedMainQuestId === questId
        );
        const archivedLinkedTasks = state.archivedTasks.filter(
          (t) => t.linkedMainQuestId === questId
        );

        // Combine, but avoid duplicates by ID
        const seenIds = new Set<string>();
        const allLinkedTasks = [...activeLinkedTasks, ...archivedLinkedTasks].filter((t) => {
          if (seenIds.has(t.id)) return false;
          seenIds.add(t.id);
          return true;
        });

        if (allLinkedTasks.length === 0) return;

        const completedCount = allLinkedTasks.filter((t) => t.completed).length;
        const totalCount = allLinkedTasks.length;
        const autoProgress = Math.round((completedCount / totalCount) * 100);

        // Update quest with new progress
        set((state) => ({
          mainQuests: state.mainQuests.map((q) =>
            q.id === questId
              ? {
                ...q,
                progressTracking: {
                  mode: q.progressTracking?.mode || 'auto',
                  linkedTasksCount: totalCount,
                  completedTasksCount: completedCount,
                  autoProgress,
                  manualProgress: q.progressTracking?.manualProgress || 0,
                  lastAIQualityCheck: q.progressTracking?.lastAIQualityCheck,
                  aiQualityScore: q.progressTracking?.aiQualityScore,
                },
                progress:
                  q.progressTracking?.mode === 'manual'
                    ? q.progress
                    : autoProgress,
              }
              : q
          ),
        }));

        // If quest is linked to a chapter, recalculate chapter progress
        if (quest.linkedChapterId && quest.seasonId) {
          get().recalculateChapterProgress(quest.seasonId, quest.linkedChapterId);
        }
      },

      recalculateChapterProgress: (seasonId, chapterId) => {
        const state = get();
        const season = state.activeSeasons.find((s) => s.id === seasonId);
        if (!season) return;

        const chapter = season.chapters.find((c) => c.id === chapterId);
        if (!chapter) return;

        // Find all quests linked to this chapter (including completed ones)
        const linkedQuests = (state.mainQuests || []).filter(
          (q) => q.linkedChapterId === chapterId && q.seasonId === seasonId
        );

        if (linkedQuests.length === 0) return;

        // Calculate weighted average progress
        // Completed quests count as 100% regardless of their stored progress
        const totalProgress = linkedQuests.reduce((sum, q) => {
          const questProgress = q.status === 'completed' ? 100 : q.progress;
          return sum + questProgress;
        }, 0);
        const chapterProgress = Math.round(totalProgress / linkedQuests.length);

        // Determine chapter status based on progress
        const allCompleted = linkedQuests.every((q) => q.status === 'completed');
        const chapterStatus = allCompleted ? 'completed' : chapter.status === 'completed' ? 'active' : chapter.status;

        // Update the chapter in the season
        set((state) => ({
          activeSeasons: state.activeSeasons.map((s) =>
            s.id === seasonId
              ? {
                ...s,
                chapters: s.chapters.map((c) =>
                  c.id === chapterId
                    ? {
                      ...c,
                      progress: chapterProgress,
                      status: chapterStatus,
                      linkedQuests: linkedQuests.map((q) => q.id),
                      completedAt: allCompleted ? (c.completedAt || new Date().toISOString()) : undefined,
                    }
                    : c
                ),
              }
              : s
          ),
        }));

        // If chapter just completed, unlock reward
        if (allCompleted && chapter.status !== 'completed') {
          const chapterTitleName = chapter.rewardTitle?.trim()
            ? chapter.rewardTitle.trim()
            : generateAutoLoreTitle('chapter', chapter.title, get().loreProfile).name;
          get().unlockTitle(chapterTitleName);
          if (!chapter.rewardTitle?.trim()) {
            const autoTitle = generateAutoLoreTitle('chapter', chapter.title, get().loreProfile);
            set((state) => ({
              titleCatalog: {
                ...state.titleCatalog,
                generatedTitles: [
                  {
                    id: `title_auto_chapter_${chapter.id}`,
                    name: autoTitle.name,
                    description: autoTitle.description,
                    rarity: autoTitle.rarity,
                    sourceType: 'chapter',
                    sourceId: chapter.id,
                    unlockedAt: new Date().toISOString(),
                    autoGenerated: true,
                  },
                  ...state.titleCatalog.generatedTitles.filter((t) => t.id !== `title_auto_chapter_${chapter.id}`),
                ],
                unlockHistory: [
                  {
                    titleId: `title_auto_chapter_${chapter.id}`,
                    reason: 'chapter_completed_auto_title',
                    timestamp: new Date().toISOString(),
                  },
                  ...state.titleCatalog.unlockHistory,
                ].slice(0, 500),
              },
            }));
          }
          if (chapter.rewardXP) {
            get().addExperience(chapter.rewardXP);
          }
        }
      },

      propagateProgressUp: (taskId) => {
        const state = get();
        const task = state.customTasks.find((t) => t.id === taskId);
        if (!task) return;

        // If task is linked to a quest, recalculate quest progress
        if (task.linkedMainQuestId) {
          get().recalculateQuestProgress(task.linkedMainQuestId);
        }
      },

      recalculateAllQuestProgress: () => {
        const state = get();
        // Iterate through all quests and recalculate their progress
        (state.mainQuests || []).forEach((quest) => {
          get().recalculateQuestProgress(quest.id);
        });
      },

      recalculateAllChapterProgress: () => {
        const state = get();
        // Iterate through all seasons and chapters
        (state.activeSeasons || []).forEach((season) => {
          (season.chapters || []).forEach((chapter) => {
            get().recalculateChapterProgress(season.id, chapter.id);
          });
        });
      },

      refreshTaskImportance: () => {
        const state = get();
        const mainQuests = state.mainQuests || [];
        const seasons = state.activeSeasons || [];

        // Update importance for all tasks based on their linked quests/chapters/seasons
        const updatedTasks = (state.customTasks || []).map((task) => {
          let newImportance = task.importance; // Default to current importance

          if (task.linkType === 'mainQuest' && task.linkedMainQuestId) {
            const linkedQuest = mainQuests.find((q) => q.id === task.linkedMainQuestId);
            if (linkedQuest) {
              newImportance = linkedQuest.importance;
            }
          } else if (task.linkType === 'chapter' && task.linkedChapterId) {
            // Find the linked chapter and inherit its importance
            const seasonId = task.linkedSeasonId || task.seasonId;
            if (seasonId) {
              const season = seasons.find(s => s.id === seasonId);
              const chapter = season?.chapters?.find(c => c.id === task.linkedChapterId);
              if (chapter && chapter.importance) {
                newImportance = chapter.importance;
              } else if (season && season.importance) {
                newImportance = season.importance;
              }
            }
          } else if (task.linkType === 'season' && task.linkedSeasonId) {
            // Inherit importance from the linked season
            const season = seasons.find(s => s.id === task.linkedSeasonId);
            if (season && season.importance) {
              newImportance = season.importance;
            }
          }

          if (task.importance !== newImportance) {
            return { ...task, importance: newImportance };
          }
          return task;
        });

        set({ customTasks: updatedTasks });
      },

      // === Weekly Goal Actions ===
      addWeeklyGoal: (goalData) => {
        const id = generateId('wg');
        const newGoal: WeeklyGoal = {
          ...goalData,
          id,
          createdAt: new Date().toISOString(),
        };

        set((state) => ({
          weeklyGoals: [...state.weeklyGoals, newGoal],
        }));

        return id;
      },

      updateWeeklyGoal: (id, updates) => {
        set((state) => ({
          weeklyGoals: state.weeklyGoals.map((goal) =>
            goal.id === id ? { ...goal, ...updates } : goal
          ),
        }));
      },

      deleteWeeklyGoal: (id) => {
        set((state) => ({
          weeklyGoals: state.weeklyGoals.filter((g) => g.id !== id),
        }));
      },

      archiveWeeklyGoal: (id) => {
        const goal = get().weeklyGoals.find((g) => g.id === id);
        if (!goal) return;

        set((state) => ({
          weeklyGoals: state.weeklyGoals.filter((g) => g.id !== id),
          archivedWeeklyGoals: [...state.archivedWeeklyGoals, goal],
        }));
      },

      // === Habit Actions ===
      addHabit: (habitData) => {
        const id = generateId('habit');
        const newHabit: Habit = {
          ...habitData,
          id,
          createdAt: new Date().toISOString(),
          streak: 0,
          longestStreak: 0,
          totalCompletions: 0,
          completionHistory: {},
        };

        set((state) => ({
          habits: [...state.habits, newHabit],
        }));

        return id;
      },

      updateHabit: (id, updates) => {
        set((state) => ({
          habits: state.habits.map((habit) =>
            habit.id === id ? { ...habit, ...updates } : habit
          ),
        }));
      },

      deleteHabit: (id) => {
        set((state) => ({
          habits: state.habits.filter((h) => h.id !== id),
          archivedHabits: state.archivedHabits.filter((h) => h.id !== id),
        }));
      },

      archiveHabit: (id) => {
        const habit = get().habits.find((h) => h.id === id);
        if (!habit) return;

        set((state) => ({
          habits: state.habits.filter((h) => h.id !== id),
          archivedHabits: [
            ...state.archivedHabits,
            { ...habit, active: false, archivedAt: new Date().toISOString() },
          ],
        }));
      },

      unarchiveHabit: (id) => {
        const habit = get().archivedHabits.find((h) => h.id === id);
        if (!habit) return;
        const { archivedAt, ...rest } = habit as Habit;
        set((state) => ({
          archivedHabits: state.archivedHabits.filter((h) => h.id !== id),
          habits: [
            ...state.habits,
            {
              ...rest,
              active: true,
            },
          ],
        }));
      },

      reorderHabits: (dragId, targetId, archived = false) => {
        if (!dragId || !targetId || dragId === targetId) return;
        set((state) => {
          const sourceList = archived ? [...state.archivedHabits] : [...state.habits];
          const from = sourceList.findIndex((h) => h.id === dragId);
          const to = sourceList.findIndex((h) => h.id === targetId);
          if (from < 0 || to < 0) return state;
          const [moved] = sourceList.splice(from, 1);
          sourceList.splice(to, 0, moved);
          return archived ? { archivedHabits: sourceList } : { habits: sourceList };
        });
      },

      checkInHabit: (id) => {
        const habit = get().habits.find((h) => h.id === id);
        if (!habit) return;

        const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
        const now = new Date().toISOString();
        const currentEntry = habit.completionHistory[today] || { count: 0, timestamps: [] };

        // Calculate new streak
        const yesterday = new Date();
        yesterday.setDate(yesterday.getDate() - 1);
        const yesterdayStr = yesterday.toISOString().split('T')[0];
        const hadYesterday = habit.completionHistory[yesterdayStr]?.count > 0;
        const hadToday = currentEntry.count > 0;

        let newStreak = habit.streak;
        if (!hadToday) {
          // First check-in today
          if (hadYesterday || habit.streak === 0) {
            newStreak = habit.streak + 1;
          } else {
            // Streak broken, start fresh
            newStreak = 1;
          }
        }

        const newLongestStreak = Math.max(habit.longestStreak, newStreak);

        set((state) => ({
          habits: state.habits.map((h) =>
            h.id === id
              ? {
                ...h,
                streak: newStreak,
                longestStreak: newLongestStreak,
                totalCompletions: h.totalCompletions + 1,
                completionHistory: {
                  ...h.completionHistory,
                  [today]: {
                    count: currentEntry.count + 1,
                    timestamps: [...currentEntry.timestamps, now],
                  },
                },
              }
              : h
          ),
        }));

        // Grant rewards if estimated duration exists
        if (habit.estimatedDuration && habit.estimatedDuration > 0) {
          const focusMinutes = habit.estimatedDuration;
          const energyCost = Math.max(1, Math.ceil(focusMinutes * (10 / 60))); // ~10 energy per hour
          const xpGain = Math.max(1, Math.ceil(focusMinutes * (40 / 60))); // ~40 xp per hour
          const goldGain = Math.max(1, Math.ceil(focusMinutes * (18 / 60))); // ~18 gold per hour

          get().updateEnergy(-energyCost, 'habit_completion');
          get().addExperience(xpGain);

          const monthStr = getCurrentMonthStr(new Date());
          set((state) => {
            const moneyRecord: GameData['financialRecords'][number] = {
              id: generateId('fin'),
              type: 'income',
              amount: goldGain,
              category: 'habit_completion',
              source: 'system',
              relatedEntityType: 'habit',
              relatedEntityId: habit.id,
              description: `Habit check-in: ${habit.name}`,
              date: new Date().toISOString(),
            };
            const nextFinancialRecords = [...state.financialRecords, moneyRecord];
            const monthSummary = calculateMonthlyMoneyFromRecords(nextFinancialRecords, monthStr);

            return {
              financialRecords: nextFinancialRecords,
              resources: {
                ...state.resources,
                time: {
                  ...state.resources.time,
                  total: (state.resources.time.total || 0) + focusMinutes,
                },
                money: {
                  ...state.resources.money,
                  balance: state.resources.money.balance + goldGain,
                  currentMonth: monthStr,
                  monthlyIncome: monthSummary.income,
                  monthlySpent: monthSummary.spent,
                  monthlyNet: monthSummary.income - monthSummary.spent,
                },
              },
            };
          });

          get().createEvent({
            type: 'task.completed', // Treat as task completion for monitor engine & stats
            entity: { type: 'habit', id: habit.id, name: habit.name },
            details: {
              energyCost,
              goldGain,
              xpGain,
              trackedMinutes: focusMinutes,
              source: 'habit_checkin'
            },
          });
        }
      },

      // === Event Actions ===
      createEvent: (params) => {
        const event: GameEvent = {
          id: generateId('evt'),
          type: params.type,
          timestamp: new Date().toISOString(),
          entity: params.entity,
          details: params.details || {},
          relations: {
            causes: [],
            causedBy: params.parentEventId ? [params.parentEventId] : [],
            subevents: [],
            parentEvent: params.parentEventId || null,
            before: [],
            after: [],
            concurrent: [],
          },
          analysis: null,
        };

        set((state) => ({
          events: [...state.events, event],
        }));

        return event;
      },

      updateEventAnalysis: (eventId, analysis) => {
        set((state) => ({
          events: state.events.map((event) =>
            event.id === eventId ? { ...event, analysis } : event
          ),
        }));
      },

      // === Resource Actions ===
      updateEnergy: (change, reason) => {
        set((state) => {
          const newEnergy = Math.max(0, Math.min(100, state.resources.energy.current + change));
          return {
            resources: {
              ...state.resources,
              energy: {
                ...state.resources.energy,
                current: newEnergy,
                lastUpdate: new Date().toISOString(),
              },
            },
            resourceLogs: [
              ...state.resourceLogs,
              {
                id: generateId('rlog'),
                resourceType: 'energy',
                change,
                reason,
                timestamp: new Date().toISOString(),
              },
            ],
          };
        });
      },

      updateMoney: (change, category, description) => {
        set((state) => {
          const prevBalance = state.resources.money.balance;
          const cappedChange = change < 0 ? -Math.min(Math.abs(change), prevBalance) : change;
          if (cappedChange === 0) {
            return {};
          }
          const newBalance = prevBalance + cappedChange;
          const isExpense = cappedChange < 0;
          const now = new Date();
          const currentMonth = getCurrentMonthStr(now);
          const source: 'manual' | 'ai' = category === 'ai' ? 'ai' : 'manual';
          const nextRecords = [
            ...state.financialRecords,
            {
              id: generateId('fin'),
              type: isExpense ? 'expense' as const : 'income' as const,
              amount: Math.abs(cappedChange),
              category,
              source,
              description,
              date: now.toISOString(),
            },
          ];
          const monthSummary = calculateMonthlyMoneyFromRecords(nextRecords, currentMonth);

          return {
            resources: {
              ...state.resources,
              money: {
                ...state.resources.money,
                balance: newBalance,
                currentMonth,
                monthlyIncome: monthSummary.income,
                monthlySpent: monthSummary.spent,
                monthlyNet: monthSummary.income - monthSummary.spent,
              },
            },
            financialRecords: nextRecords,
          };
        });
      },

      recalculateMonthlyMoney: (month) => {
        set((state) => {
          const targetMonth = month || state.resources.money.currentMonth || getCurrentMonthStr();
          const monthSummary = calculateMonthlyMoneyFromRecords(state.financialRecords, targetMonth);
          return {
            resources: {
              ...state.resources,
              money: {
                ...state.resources.money,
                currentMonth: targetMonth,
                monthlyIncome: monthSummary.income,
                monthlySpent: monthSummary.spent,
                monthlyNet: monthSummary.income - monthSummary.spent,
              },
            },
          };
        });
      },

      // === Experience Actions ===
      addExperience: (xp) => {
        set((state) => {
          const newExperience = Math.max(0, state.experience + xp); // Prevent negative XP
          const newLevel = calculateLevelFromXP(newExperience);
          return {
            experience: newExperience,
            level: Math.min(newLevel, 100), // Cap at level 100
          };
        });
        const unlockedNames = evaluateAutoTitleUnlockNames(get() as unknown as GameData);
        unlockedNames.forEach((name) => get().unlockTitle(name));
      },

      addSkillXP: (category, skill, xp, reason = 'manual') => {
        if (xp === 0) return;
        const state = get();
        const skillMap = state.skills as MutableSkillMap;
        const skillKey = String(skill);
        const skillEntry = skillMap?.[category]?.[skillKey];
        if (!skillEntry) return;

        const nextSkills = structuredClone(state.skills) as Skills;
        const nextSkillMap = nextSkills as MutableSkillMap;
        const target = nextSkillMap[category][skillKey];
        target.xp = Math.max(0, target.xp + xp);

        let leveledUp = false;
        while (target.xp >= target.maxXp) {
          target.xp -= target.maxXp;
          target.level += 1;
          target.maxXp = Math.ceil(target.maxXp * 1.15);
          leveledUp = true;
        }

        set({ skills: nextSkills });

        get().createEvent({
          type: 'skill.xp',
          entity: { type: 'skill', id: `${String(category)}.${String(skill)}`, name: `${String(category)}.${String(skill)}` },
          details: { xp, reason, level: target.level, currentXp: target.xp, maxXp: target.maxXp },
        });

        if (leveledUp) {
          get().createEvent({
            type: 'skill.levelup',
            entity: { type: 'skill', id: `${String(category)}.${String(skill)}`, name: `${String(category)}.${String(skill)}` },
            details: { reason, level: target.level },
          });
        }
        const unlockedNames = evaluateAutoTitleUnlockNames(get() as unknown as GameData);
        unlockedNames.forEach((name) => get().unlockTitle(name));
      },

      setSkillLevel: (category, skill, level) => {
        const state = get();
        const skillMap = state.skills as MutableSkillMap;
        const skillKey = String(skill);
        const skillEntry = skillMap?.[category]?.[skillKey];
        if (!skillEntry) return;
        const safeLevel = Math.max(1, Math.floor(level));
        const nextSkills = structuredClone(state.skills) as Skills;
        const nextSkillMap = nextSkills as MutableSkillMap;
        const target = nextSkillMap[category][skillKey];
        target.level = safeLevel;
        target.xp = Math.min(target.xp, target.maxXp - 1);
        set({ skills: nextSkills });
      },

      setBeliefMode: (mode) => {
        set(
          produce((state: GameStore) => {
            state.beliefSystem.mode = mode;
          })
        );
      },

      setProfileBeliefs: (beliefs) => {
        const normalizedBeliefs = beliefs
          .map((item) => item.trim())
          .filter((item, idx, arr) => item.length > 0 && arr.indexOf(item) === idx)
          .slice(0, 20);
        set(
          produce((state: GameStore) => {
            state.beliefSystem.profileBeliefs = normalizedBeliefs;
          })
        );
      },

      updateLoreProfile: (updates) => {
        set((state) => ({
          loreProfile: {
            ...state.loreProfile,
            ...updates,
            version: Math.max(1, (state.loreProfile.version || 1)),
          },
        }));
      },

      runOrchestrationCycle: (trigger, note) => {
        const now = new Date().toISOString();
        const state = get();
        const completedTasks = [...state.customTasks, ...state.archivedTasks]
          .filter((t) => t.completed || t.status === 'completed').length;
        const completedQuests = state.mainQuests.filter((q) => q.status === 'completed').length;
        const activeQuestCount = state.mainQuests.filter((q) => q.status === 'active').length;
        const deltaMomentum = trigger === 'quest_completed' ? 4 : trigger === 'weekly_review_saved' ? 3 : 2;
        const deltaStability = trigger === 'weekly_review_saved' ? 3 : 1;
        const currentMomentum = Number(state.worldState.worldVariables.momentum || 0);
        const currentStability = Number(state.worldState.worldVariables.stability || 0);
        const nextMomentum = clampNumber(currentMomentum + deltaMomentum, 0, 100);
        const nextStability = clampNumber(currentStability + deltaStability, 0, 100);

        const proposals: string[] = [];
        const autoActions: string[] = [];
        const pendingConfirmations: string[] = [];
        proposals.push(`Êé®Ëøõ‰∏ñÁïåÂèòÈáè momentum ${currentMomentum} -> ${nextMomentum}`);
        proposals.push(`Êé®Ëøõ‰∏ñÁïåÂèòÈáè stability ${currentStability} -> ${nextStability}`);
        if (completedQuests > 0 && completedQuests % 3 === 0) {
          proposals.push('Ê£ÄÊµãÂà∞Èò∂ÊÆµÈáåÁ®ãÁ¢ëÔºåÂª∫ËÆÆÁîüÊàê‰∏≠Á≠âÁ®ÄÊúâ‰∏ñÁïå‰∫ã‰ª∂');
          pendingConfirmations.push('world_event_milestone');
        }

        set((prev) => ({
          worldState: {
            ...prev.worldState,
            epoch: trigger === 'weekly_review_saved' ? prev.worldState.epoch + 1 : prev.worldState.epoch,
            worldVariables: {
              ...prev.worldState.worldVariables,
              momentum: nextMomentum,
              stability: nextStability,
              activeQuestCount,
              completedTaskCount: completedTasks,
              completedQuestCount: completedQuests,
            },
            lastEvolutionAt: now,
          },
          orchestrationLog: [
            {
              id: generateId('orch'),
              trigger,
              timestamp: now,
              inputSummary: note || `tasks=${completedTasks}, quests=${completedQuests}, activeQuests=${activeQuestCount}`,
              proposals,
              autoActions: [...autoActions, 'world_variables_updated'],
              pendingConfirmations,
              rolledBack: false,
            },
            ...(prev.orchestrationLog || []),
          ].slice(0, 200),
        }));
      },

      resetPlayerStats: (newLevel = 1, newXP = 0) => {
        const safeLevel = Math.max(1, Math.min(newLevel, 100));
        const safeXP = Math.max(0, newXP);
        set({
          level: safeLevel,
          experience: safeXP,
          stats: { life: 75, intelligence: 95, spirit: 95, action: 75, agility: 50, charm: 70 },
        });
      },

      updateStats: (statChanges) => {
        set((state) => {
          const newStats = { ...state.stats };
          for (const [key, delta] of Object.entries(statChanges)) {
            if (key in newStats && typeof delta === 'number') {
              const currentValue = newStats[key as keyof typeof newStats];
              // Stats are 0-100, apply delta
              newStats[key as keyof typeof newStats] = Math.max(0, Math.min(100, currentValue + delta));
            }
          }
          return { stats: newStats };
        });
      },

      // === Title Actions ===
      setCurrentTitle: (title) => {
        set({ currentTitle: title });
      },

      unlockTitle: (title) => {
        set((state) => ({
          unlockedTitles: state.unlockedTitles.includes(title)
            ? state.unlockedTitles
            : [...state.unlockedTitles, title],
        }));
      },

      removeTitle: (title) => {
        set((state) => ({
          unlockedTitles: state.unlockedTitles.filter((t) => t !== title),
          currentTitle: state.currentTitle === title ? '' : state.currentTitle,
        }));
      },

      addRewardActionLog: (text) => {
        const content = text.trim();
        if (!content) return;
        set(
          produce((state: GameStore) => {
            state.rewardActionLogs = [
              {
                id: generateId('reward_log'),
                text: content,
                timestamp: new Date().toISOString(),
              },
              ...(state.rewardActionLogs || []),
            ].slice(0, 50);
          })
        );
      },

      updateRewardPricing: (updates) => {
        set((state) => {
          const nextPricing = {
            ...state.rewardPricing,
            ...updates,
          };
          return {
            rewardPricing: {
              eat: Math.max(1, Math.floor(nextPricing.eat || DEFAULT_REWARD_PRICING.eat)),
              drink: Math.max(1, Math.floor(nextPricing.drink || DEFAULT_REWARD_PRICING.drink)),
              buy: Math.max(1, Math.floor(nextPricing.buy || DEFAULT_REWARD_PRICING.buy)),
              watch: Math.max(1, Math.floor(nextPricing.watch || DEFAULT_REWARD_PRICING.watch)),
              play: Math.max(1, Math.floor(nextPricing.play || DEFAULT_REWARD_PRICING.play)),
              rest: Math.max(1, Math.floor(nextPricing.rest || DEFAULT_REWARD_PRICING.rest)),
              other: Math.max(1, Math.floor(nextPricing.other || DEFAULT_REWARD_PRICING.other)),
            },
          };
        });
      },

      redeemRewardSticker: (id) => {
        const state = get();
        const target = (state.rewardPool || []).find((item) => item.id === id);
        if (!target) return { success: false, reason: 'not_found' };
        if (target.status !== 'available') return { success: false, reason: 'already_redeemed' };
        const cost = target.priceGold || 0;
        if (state.resources.money.balance < cost) return { success: false, reason: 'insufficient_gold' };

        const now = new Date();
        const currentMonth = getCurrentMonthStr(now);
        set((prev) => {
          const nextRecords = [
            ...prev.financialRecords,
            {
              id: generateId('fin'),
              type: 'expense' as const,
              amount: Math.abs(cost),
              category: 'reward',
              source: 'reward_redeem' as const,
              relatedEntityType: 'reward' as const,
              relatedEntityId: id,
              description: `Redeem reward: ${target.rawText}`,
              date: now.toISOString(),
            },
          ];
          const monthSummary = calculateMonthlyMoneyFromRecords(nextRecords, currentMonth);
          return {
            rewardPool: (prev.rewardPool || []).map((item) =>
              item.id === id
                ? { ...item, status: 'redeemed', redeemedAt: now.toISOString(), redeemedCostGold: cost }
                : item
            ),
            resources: {
              ...prev.resources,
              money: {
                ...prev.resources.money,
                balance: prev.resources.money.balance - cost,
                currentMonth,
                monthlyIncome: monthSummary.income,
                monthlySpent: monthSummary.spent,
                monthlyNet: monthSummary.income - monthSummary.spent,
              },
            },
            financialRecords: nextRecords,
          };
        });

        return { success: true };
      },

      restoreRewardSticker: (_id) => {
        return { success: false, reason: 'non_reversible' };
      },

      deleteRewardSticker: (id) => {
        set((state) => ({
          rewardPool: (state.rewardPool || []).filter((item) => item.id !== id),
        }));
      },

      updateRewardStickerPosition: (id, x, y, zIndex) => {
        set(
          produce((state: GameStore) => {
            const target = (state.rewardPool || []).find((item) => item.id === id);
            if (!target) return;
            target.x = x;
            target.y = y;
            target.zIndex = zIndex ?? target.zIndex;
          })
        );
      },

      updateRewardStickerData: (id, updates) => {
        set((state) => ({
          rewardPool: (state.rewardPool || []).map((item) =>
            item.id === id
              ? (() => {
                const nextVerb = updates.verb ?? item.verb;
                const nextQuantity = updates.quantity;
                const pricing = estimateRewardPricing(nextVerb, nextQuantity, state.rewardPricing || DEFAULT_REWARD_PRICING);
                return {
                  ...item,
                  rawText: updates.rawText ?? item.rawText,
                  verb: nextVerb,
                  object: updates.object ?? item.object,
                  quantity: nextQuantity,
                  unit: updates.unit,
                  priceTier: pricing.priceTier,
                  priceGold: pricing.priceGold,
                };
              })()
              : item
          ),
        }));
      },

      randomizeRewardBoardLayout: () => {
        set((state) => {
          const occupied: Array<{ x: number; y: number }> = [];
          let nextZ = 1;
          return {
            rewardPool: (state.rewardPool || []).map((item) => {
              if (item.status !== 'available') return item;
              const placement = createStickerPlacement(occupied);
              occupied.push({ x: placement.x, y: placement.y });
              nextZ += 1;
              return {
                ...item,
                x: placement.x,
                y: placement.y,
                rotation: placement.rotation,
                zIndex: nextZ,
              };
            }),
          };
        });
      },

      // === Daily Reset ===
      checkDailyReset: () => {
        const today = new Date().toDateString();
        const state = get();
        const currentMonth = getCurrentMonthStr();
        const monthChanged = state.resources.money.currentMonth !== currentMonth;
        const todayDate = new Date();
        todayDate.setHours(0, 0, 0, 0);
        const lastResetDate = parseLegacyDayString(state.lastReset);
        const nextSnapshots: Record<string, DailyCompletionSnapshot> = {
          ...(state.dailyCompletionSnapshots || {}),
        };

        if (lastResetDate) {
          const cursor = new Date(lastResetDate);
          while (cursor < todayDate) {
            const dayKey = toDateKey(cursor);
            nextSnapshots[dayKey] = computeDailySnapshotFromState(state, dayKey);
            cursor.setDate(cursor.getDate() + 1);
          }
        } else {
          const yesterday = new Date(todayDate);
          yesterday.setDate(yesterday.getDate() - 1);
          const dayKey = toDateKey(yesterday);
          nextSnapshots[dayKey] = computeDailySnapshotFromState(state, dayKey);
        }

        if (state.lastReset !== today || monthChanged) {
          const monthSummary = calculateMonthlyMoneyFromRecords(state.financialRecords, currentMonth);
          set({
            dailyTasks: { shutdown: false, laugh: false, vision: false, walk: false, signal: false, log: false },
            dailyCareCompleted: false,
            lastReset: today,
            dailyCompletionSnapshots: nextSnapshots,
            pomodoro: {
              ...state.pomodoro,
              completedToday: 0,
              lastPomodoroDate: today,
            },
            // ÊØèÊó•Á≤æÂäõÊÅ¢Â§ç - ÊÅ¢Â§çÂà∞ 80 (Daily energy recovery)
            resources: {
              ...state.resources,
              money: {
                ...state.resources.money,
                currentMonth,
                monthlyIncome: monthSummary.income,
                monthlySpent: monthSummary.spent,
                monthlyNet: monthSummary.income - monthSummary.spent,
              },
              energy: {
                ...state.resources.energy,
                current: 80,
                lastUpdate: new Date().toISOString(),
              },
            },
          });
        } else {
          set({
            dailyCompletionSnapshots: nextSnapshots,
          });
        }

        // Check for recurring tasks generation
        get().checkRecurringTasks();

        // Check for quest unlocks
        get().checkQuestUnlocks();

        // Recalculate all quest progress on page load (fixes historical data)
        get().recalculateAllQuestProgress();

        // Recalculate all chapter progress on page load
        get().recalculateAllChapterProgress();
      },

      // === Check Quest Unlocks ===
      checkQuestUnlocks: () => {
        const state = get();
        const today = new Date();
        today.setHours(0, 0, 0, 0);

        // 1. Check Main Quest Unlocks
        const updatedQuests = state.mainQuests.map(quest => {
          if (quest.status !== 'locked' || !quest.unlockTime) {
            return quest;
          }

          // Parse unlock date
          const match = quest.unlockTime.match(/^(\d{4})-(\d{2})-(\d{2})$/);
          if (!match) return quest;

          const [, year, month, day] = match.map(Number);
          const unlockDate = new Date(year, month - 1, day);
          unlockDate.setHours(0, 0, 0, 0);

          // If today >= unlock date, unlock the quest
          if (today >= unlockDate) {
            console.log(`[checkQuestUnlocks] Unlocking quest: ${quest.title}`);
            return { ...quest, status: 'active' as const };
          }

          return quest;
        });

        // 2. Check Season StartDate Lock/Unlock
        const seasonStatusUpdated = state.activeSeasons.map((season) => {
          const effective = getEffectiveSeasonStatus(season, today);
          if (season.status === effective) return season;
          return { ...season, status: effective };
        });

        // 3. Check Chapter Unlocks
        const updatedChaptersBySeason = seasonStatusUpdated.map(season => {
          let seasonChanged = false;
          const updatedChapters = season.chapters.map(chapter => {
            if (chapter.status !== 'locked' || !chapter.unlockTime) {
              return chapter;
            }

            // Parse unlock date
            const match = chapter.unlockTime.match(/^(\d{4})-(\d{2})-(\d{2})$/);
            if (!match) return chapter;

            const [, year, month, day] = match.map(Number);
            const unlockDate = new Date(year, month - 1, day);
            unlockDate.setHours(0, 0, 0, 0);

            // If today >= unlock date, unlock the chapter
            if (today >= unlockDate) {
              console.log(`[checkQuestUnlocks] Unlocking chapter: ${chapter.title}`);
              seasonChanged = true;
              return { ...chapter, status: 'active' as const };
            }

            return chapter;
          });

          if (seasonChanged) {
            return { ...season, chapters: updatedChapters };
          }
          return season;
        });

        // Only update if there were changes
        const hasQuestChanges = updatedQuests.some((q, i) => q.status !== state.mainQuests[i].status);
        const hasSeasonChanges = updatedChaptersBySeason.some((s, i) => s !== state.activeSeasons[i]);

        if (hasQuestChanges || hasSeasonChanges) {
          set({
            mainQuests: hasQuestChanges ? updatedQuests : state.mainQuests,
            activeSeasons: hasSeasonChanges ? updatedChaptersBySeason : state.activeSeasons
          });
        }
      },

      // === Data Management ===
      loadFromJSON: (data) => {
        set((state) => normalizeStoreData(state, data));
        get().recalculateMonthlyMoney(getCurrentMonthStr());
        get().recalculateAllQuestProgress();
        get().recalculateAllChapterProgress();
      },

      exportData: () => {
        const state = get();
        // Return only data, not actions
        const {
          addTask, updateTask, deleteTask, completeTask, archiveTask, unarchiveTask,
          addRecurringTask, updateRecurringTask, deleteRecurringTask, checkRecurringTasks,
          addQuest, updateQuest, deleteQuest, archiveQuest, unarchiveQuest, updateArchivedQuest, convertTaskToQuest,
          addSeason, updateSeason,
          recalculateQuestProgress, recalculateChapterProgress, recalculateAllChapterProgress, propagateProgressUp, refreshTaskImportance,
          addWeeklyGoal, updateWeeklyGoal, deleteWeeklyGoal, archiveWeeklyGoal,
          addHabit, updateHabit, deleteHabit, archiveHabit, unarchiveHabit, reorderHabits, checkInHabit,
          createEvent, updateEventAnalysis,
          updateEnergy, updateMoney, recalculateMonthlyMoney, addExperience, addSkillXP, setSkillLevel, setBeliefMode, setProfileBeliefs, updateLoreProfile, runOrchestrationCycle, resetPlayerStats, updateStats, setCurrentTitle, unlockTitle, removeTitle,
          redeemRewardSticker, restoreRewardSticker, deleteRewardSticker, updateRewardStickerPosition, updateRewardStickerData, randomizeRewardBoardLayout, checkDailyReset,
          loadFromJSON, exportData, resetData,
          ...data
        } = state;
        return data as GameData;
      },

      resetData: () => {
        set(initialState);
      },
    }),
    {
      name: STORAGE_KEY,
      storage: createJSONStorage(() => ({
        getItem: (name) => {
          const str = localStorage.getItem(name);
          return str;
        },
        setItem: (name, value) => {
          try {
            localStorage.setItem(name, value);
          } catch (e) {
            console.warn('[Storage] Failed to save, localStorage might be full:', e);
            // Don't crash the app if storage fails
          }
        },
        removeItem: (name) => localStorage.removeItem(name),
      })),
      partialize: (state) => {
        // Only persist data, not actions
        const {
          addTask, updateTask, deleteTask, completeTask, archiveTask, unarchiveTask,
          addRecurringTask, updateRecurringTask, deleteRecurringTask, checkRecurringTasks, triggerRecurringTask,
          addQuest, updateQuest, deleteQuest, archiveQuest, unarchiveQuest, updateArchivedQuest, convertTaskToQuest,
          addSeason, updateSeason,
          recalculateQuestProgress, recalculateChapterProgress, recalculateAllChapterProgress, propagateProgressUp, refreshTaskImportance,
          addWeeklyGoal, updateWeeklyGoal, deleteWeeklyGoal, archiveWeeklyGoal,
          addHabit, updateHabit, deleteHabit, archiveHabit, unarchiveHabit, reorderHabits, checkInHabit,
          createEvent, updateEventAnalysis,
          updateEnergy, updateMoney, recalculateMonthlyMoney, addExperience, addSkillXP, setSkillLevel, setBeliefMode, setProfileBeliefs, updateLoreProfile, runOrchestrationCycle, resetPlayerStats, updateStats, setCurrentTitle, unlockTitle, removeTitle,
          redeemRewardSticker, restoreRewardSticker, deleteRewardSticker, updateRewardStickerPosition, updateRewardStickerData, randomizeRewardBoardLayout, checkDailyReset,
          addRewardActionLog,
          loadFromJSON, exportData, resetData,
          ...data
        } = state;
        return data;
      },
      version: 10, // Increment version for migration
      migrate: (persistedState: unknown, version: number) => {
        const state = (persistedState || {}) as Partial<GameData> & { coins?: number };
        if (state && state.resources) {
          state.resources.money = state.resources.money || {};
          if (
            typeof state.resources.money.balance !== 'number' &&
            typeof state.coins === 'number'
          ) {
            state.resources.money.balance = state.coins;
          }
          if (typeof state.resources.money.currentMonth !== 'string') {
            state.resources.money.currentMonth = getCurrentMonthStr();
          }
          if (typeof state.resources.money.monthlyNet !== 'number') {
            const monthSummary = calculateMonthlyMoneyFromRecords(
              Array.isArray(state.financialRecords) ? state.financialRecords : [],
              state.resources.money.currentMonth
            );
            state.resources.money.monthlyIncome = monthSummary.income;
            state.resources.money.monthlySpent = monthSummary.spent;
            state.resources.money.monthlyNet = monthSummary.income - monthSummary.spent;
          }
        }
        if (state && state.coins !== undefined) {
          delete state.coins;
        }
        if (state && !state.skills) {
          state.skills = DEFAULT_SKILLS;
        }
        if (state && !state.beliefSystem) {
          state.beliefSystem = DEFAULT_BELIEF_SYSTEM;
        }
        if (state && !state.loreProfile) {
          state.loreProfile = DEFAULT_LORE_PROFILE;
        }
        if (state && !state.worldState) {
          state.worldState = DEFAULT_WORLD_STATE;
        }
        if (state && !state.progressionConfig) {
          state.progressionConfig = DEFAULT_PROGRESSION_CONFIG;
        }
        if (state && !state.titleCatalog) {
          state.titleCatalog = DEFAULT_TITLE_CATALOG;
        }
        if (state && !Array.isArray(state.orchestrationLog)) {
          state.orchestrationLog = [];
        }
        if (state && typeof state.dailyCompletionSnapshots !== 'object') {
          state.dailyCompletionSnapshots = {};
        }
        if (state && !Array.isArray(state.rewardActionLogs)) {
          state.rewardActionLogs = [];
        }
        if (state && !Array.isArray(state.rewardPool)) {
          state.rewardPool = [];
        }
        if (state && !state.rewardPricing) {
          state.rewardPricing = DEFAULT_REWARD_PRICING;
        } else if (state && state.rewardPricing) {
          state.rewardPricing = {
            ...DEFAULT_REWARD_PRICING,
            ...state.rewardPricing,
          };
        }
        if (state && Array.isArray(state.rewardPool)) {
          // v2 migration: reshuffle all stickers for a natural board layout.
          if (version < 2) {
            const occupied: Array<{ x: number; y: number }> = [];
            state.rewardPool = state.rewardPool.map((item) => {
              const pricing = estimateRewardPricing(item.verb || 'other', item.quantity, state.rewardPricing);
              const placement = createStickerPlacement(occupied);
              occupied.push({ x: placement.x, y: placement.y });
              return {
                ...item,
                x: placement.x,
                y: placement.y,
                rotation: placement.rotation,
                zIndex: item.zIndex ?? placement.zIndex,
                priceTier: item.priceTier || pricing.priceTier,
                priceGold: typeof item.priceGold === 'number' && item.priceGold > 0 ? item.priceGold : pricing.priceGold,
              };
            });
          } else {
            state.rewardPool = state.rewardPool.map((item) => {
              const pricing = estimateRewardPricing(item.verb || 'other', item.quantity, state.rewardPricing);
              if (
                typeof item.x === 'number' &&
                typeof item.y === 'number' &&
                typeof item.rotation === 'number' &&
                typeof item.zIndex === 'number'
              ) {
                return {
                  ...item,
                  priceTier: item.priceTier || pricing.priceTier,
                  priceGold: typeof item.priceGold === 'number' && item.priceGold > 0 ? item.priceGold : pricing.priceGold,
                };
              }
              const placement = createStickerPlacement();
              return {
                ...item,
                x: placement.x,
                y: placement.y,
                rotation: placement.rotation,
                zIndex: placement.zIndex,
                priceTier: item.priceTier || pricing.priceTier,
                priceGold: typeof item.priceGold === 'number' && item.priceGold > 0 ? item.priceGold : pricing.priceGold,
              };
            });
          }
          if (version < 6) {
            state.rewardPool = state.rewardPool.map((item) => {
              if (item.verb !== 'eat' && item.verb !== 'drink') return item;
              const pricing = estimateRewardPricing(item.verb, item.quantity, state.rewardPricing);
              return {
                ...item,
                priceTier: pricing.priceTier,
                priceGold: pricing.priceGold,
              };
            });
          }
          if (version < 10) {
            state.rewardPool = state.rewardPool.map((item) => {
              const normalizedVerb = normalizeRewardVerb(item);
              const pricing = estimateRewardPricing(normalizedVerb, item.quantity, state.rewardPricing);
              return {
                ...item,
                verb: normalizedVerb,
                priceTier: pricing.priceTier,
                priceGold: pricing.priceGold,
              };
            });
          }
        }
        if (version === 0) {
          // Migration from v0 to v1: Map old effort types to new ones
          const current = state as GameData;

          const mapEffort = (effort: string): string => {
            if (effort === 'tiny') return 'light';
            if (effort === 'moderate') return 'medium';
            if (effort === 'massive') return 'heavy';
            if (['light', 'medium', 'heavy'].includes(effort)) return effort;
            return 'medium'; // Default fallback
          };

          if (current.customTasks) {
            current.customTasks = current.customTasks.map(t => ({
              ...t,
              effort: mapEffort(t.effort as string) as CustomTask['effort']
            }));
          }

          if (current.recurringTasks) {
            current.recurringTasks = current.recurringTasks.map(t => ({
              ...t,
              effort: mapEffort(t.effort as string) as RecurringTask['effort']
            }));
          }
        }
        return state;
      },
    }
  )
);
